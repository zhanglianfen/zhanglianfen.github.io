const e=JSON.parse('{"key":"v-085372f8","path":"/zh/basics/design-principles/L.html","title":"里氏替换原则","lang":"zh-CN","frontmatter":{"category":["设计原则和思想"],"description":"里氏替换原则 整体上来讲，这个设计原则是比较简单、容易理解和掌握的。今天主要通过几个反例看看哪些代码是违反里式替换原则的？我们该如何将它们改造成满足里式替换原则？除此之外，这条原则从定义上看起来，跟我们之前讲过的“多态”有点类似。 如何理解“里式替换原则”？ 里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。这个原则最早是在 1986 年由 Barbara Liskov 提出，他是这么描述这条原则的： If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。","head":[["meta",{"property":"og:url","content":"https://theme-zhang.netlify.app/zh/basics/design-principles/L.html"}],["meta",{"property":"og:site_name","content":"zhang"}],["meta",{"property":"og:title","content":"里氏替换原则"}],["meta",{"property":"og:description","content":"里氏替换原则 整体上来讲，这个设计原则是比较简单、容易理解和掌握的。今天主要通过几个反例看看哪些代码是违反里式替换原则的？我们该如何将它们改造成满足里式替换原则？除此之外，这条原则从定义上看起来，跟我们之前讲过的“多态”有点类似。 如何理解“里式替换原则”？ 里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。这个原则最早是在 1986 年由 Barbara Liskov 提出，他是这么描述这条原则的： If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-12-09T06:04:07.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"article:modified_time","content":"2022-12-09T06:04:07.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://theme-zhang.netlify.app/en/basics/design-principles/L.html"}]]},"headers":[{"level":2,"title":"如何理解“里式替换原则”？","slug":"如何理解-里式替换原则","link":"#如何理解-里式替换原则","children":[]},{"level":2,"title":"哪些代码明显违背了 LSP？","slug":"哪些代码明显违背了-lsp","link":"#哪些代码明显违背了-lsp","children":[{"level":3,"title":"1. 子类违背父类声明要实现的功能","slug":"_1-子类违背父类声明要实现的功能","link":"#_1-子类违背父类声明要实现的功能","children":[]},{"level":3,"title":"2. 子类违背父类对输入、输出、异常的约定","slug":"_2-子类违背父类对输入、输出、异常的约定","link":"#_2-子类违背父类对输入、输出、异常的约定","children":[]},{"level":3,"title":"3. 子类违背父类注释中所罗列的任何特殊说明","slug":"_3-子类违背父类注释中所罗列的任何特殊说明","link":"#_3-子类违背父类注释中所罗列的任何特殊说明","children":[]}]},{"level":2,"title":"重点回顾","slug":"重点回顾","link":"#重点回顾","children":[]},{"level":2,"title":"课堂讨论","slug":"课堂讨论","link":"#课堂讨论","children":[]}],"git":{"createdTime":1670565847000,"updatedTime":1670565847000,"contributors":[{"name":"zhanglf","email":"454486214@qq.com","commits":1}]},"readingTime":{"minutes":8.8,"words":2640},"filePathRelative":"zh/basics/design-principles/L.md","localizedDate":"2022年12月9日","excerpt":"<h1> 里氏替换原则</h1>\\n<p>整体上来讲，这个设计原则是比较简单、容易理解和掌握的。今天主要通过几个反例看看哪些代码是违反里式替换原则的？我们该如何将它们改造成满足里式替换原则？除此之外，这条原则从定义上看起来，跟我们之前讲过的“多态”有点类似。</p>\\n<h2> 如何理解“里式替换原则”？</h2>\\n<p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。这个原则最早是在 1986 年由 Barbara Liskov 提出，他是这么描述这条原则的：</p>\\n<blockquote>\\n<p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。</p>\\n</blockquote>","autoDesc":true}');export{e as data};
