const e=JSON.parse('{"key":"v-fff4da9a","path":"/zh/language/Java/multithreading/lock/Synchronized.html","title":"Synchronized","lang":"zh-CN","frontmatter":{"category":["Java"],"description":"Synchronized 提示 线程释放锁之后，如何通知其他线程获取锁？ 上一节提到，解决多线程执行非原子操作，导致的线程不安全问题，其中最常用的解决方案便是加锁。Java语言提供了两种类型的锁，一种是synchronized关键字，一种是Lock工具类。在JDK1.5及其以前版本中，synchronized的实现比较简陋，性能没有后起之秀Lock高，但是，在JDK1.6及其之后的版本中，Java对synchronized做了大量优化，其基本实现原理跟Lock的基本实现原理趋于一致，因此，在性能方面，两者也就相差无几了。 接下来我们先重点讲解synchronized。其中，本节课讲解synchronized的基本用法，以及重量级锁的实现原理，下一节讲解Java对synchronized的各种优化，包括偏向锁、轻量级锁、自旋锁、锁粗化、锁消除等。 在开始今天的内容之前，我仍然有几个问题留给你思考：某个Java线程使用synchronized之后，如果没有获取锁，Java是如何阻塞当前代码的执行的？如何停止对应的内核线程执行？当另一个线程释放锁之后，如何通知等待锁的线程获取锁？ 带着这些问题，我们开始今天的学习。","head":[["meta",{"property":"og:url","content":"https://theme-zhang.netlify.app/zh/language/Java/multithreading/lock/Synchronized.html"}],["meta",{"property":"og:site_name","content":"zhang"}],["meta",{"property":"og:title","content":"Synchronized"}],["meta",{"property":"og:description","content":"Synchronized 提示 线程释放锁之后，如何通知其他线程获取锁？ 上一节提到，解决多线程执行非原子操作，导致的线程不安全问题，其中最常用的解决方案便是加锁。Java语言提供了两种类型的锁，一种是synchronized关键字，一种是Lock工具类。在JDK1.5及其以前版本中，synchronized的实现比较简陋，性能没有后起之秀Lock高，但是，在JDK1.6及其之后的版本中，Java对synchronized做了大量优化，其基本实现原理跟Lock的基本实现原理趋于一致，因此，在性能方面，两者也就相差无几了。 接下来我们先重点讲解synchronized。其中，本节课讲解synchronized的基本用法，以及重量级锁的实现原理，下一节讲解Java对synchronized的各种优化，包括偏向锁、轻量级锁、自旋锁、锁粗化、锁消除等。 在开始今天的内容之前，我仍然有几个问题留给你思考：某个Java线程使用synchronized之后，如果没有获取锁，Java是如何阻塞当前代码的执行的？如何停止对应的内核线程执行？当另一个线程释放锁之后，如何通知等待锁的线程获取锁？ 带着这些问题，我们开始今天的学习。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-12-09T06:04:07.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"article:modified_time","content":"2022-12-09T06:04:07.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://theme-zhang.netlify.app/en/language/Java/multithreading/lock/Synchronized.html"}]]},"headers":[{"level":2,"title":"基本用法和原理","slug":"基本用法和原理","link":"#基本用法和原理","children":[{"level":3,"title":"一、两种作用范围","slug":"一、两种作用范围","link":"#一、两种作用范围","children":[]},{"level":3,"title":"二、对象锁和类锁","slug":"二、对象锁和类锁","link":"#二、对象锁和类锁","children":[]},{"level":3,"title":"三、对应的字节码","slug":"三、对应的字节码","link":"#三、对应的字节码","children":[]},{"level":3,"title":"四、底层实现原理","slug":"四、底层实现原理","link":"#四、底层实现原理","children":[]}]},{"level":2,"title":"Synchronized优化","slug":"synchronized优化","link":"#synchronized优化","children":[{"level":3,"title":"一、偏向锁","slug":"一、偏向锁","link":"#一、偏向锁","children":[]},{"level":3,"title":"二、轻量级锁","slug":"二、轻量级锁","link":"#二、轻量级锁","children":[]},{"level":3,"title":"三、锁消除","slug":"三、锁消除","link":"#三、锁消除","children":[]},{"level":3,"title":"四、锁粗化","slug":"四、锁粗化","link":"#四、锁粗化","children":[]}]},{"level":2,"title":"思考题","slug":"思考题","link":"#思考题","children":[]}],"git":{"createdTime":1670565847000,"updatedTime":1670565847000,"contributors":[{"name":"zhanglf","email":"454486214@qq.com","commits":1}]},"readingTime":{"minutes":32.86,"words":9857},"filePathRelative":"zh/language/Java/multithreading/lock/Synchronized.md","localizedDate":"2022年12月9日","excerpt":"<h1> <strong>Synchronized</strong></h1>\\n<div class=\\"custom-container tip\\">\\n<p class=\\"custom-container-title\\">提示</p>\\n<p><strong>线程释放锁之后，如何通知其他线程获取锁？</strong></p>\\n<p>上一节提到，解决多线程执行非原子操作，导致的线程不安全问题，其中最常用的解决方案便是加锁。Java语言提供了两种类型的锁，一种是synchronized关键字，一种是Lock工具类。在JDK1.5及其以前版本中，synchronized的实现比较简陋，性能没有后起之秀Lock高，但是，在JDK1.6及其之后的版本中，Java对synchronized做了大量优化，其基本实现原理跟Lock的基本实现原理趋于一致，因此，在性能方面，两者也就相差无几了。</p>\\n<p>接下来我们先重点讲解synchronized。其中，本节课讲解synchronized的基本用法，以及重量级锁的实现原理，下一节讲解Java对synchronized的各种优化，包括偏向锁、轻量级锁、自旋锁、锁粗化、锁消除等。</p>\\n<p>在开始今天的内容之前，我仍然有几个问题留给你思考：某个Java线程使用synchronized之后，如果没有获取锁，Java是如何阻塞当前代码的执行的？如何停止对应的内核线程执行？当另一个线程释放锁之后，如何通知等待锁的线程获取锁？</p>\\n<p>带着这些问题，我们开始今天的学习。</p>\\n</div>","autoDesc":true}');export{e as data};
