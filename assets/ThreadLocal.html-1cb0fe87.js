const e=JSON.parse('{"key":"v-e2f9e85e","path":"/zh/language/Java/multithreading/lockless/ThreadLocal.html","title":"ThreadLocal","lang":"zh-CN","frontmatter":{"category":["Java"],"description":"ThreadLocal 提示 对于无锁编程，我们已经讲解了CAS、原子类、累加器，本节，我们讲解无锁编程中的最后一个知识点：ThreadLocal。我们知道，共享变量是代码存在线程安全的根本原因之一。在某些特殊的业务场景下，我们可以使用ThreadLocal线程局部变量替代共享变量，以实现在不需要加锁的情况下达到线程安全。 一、基本用法 在Java中，我们可以将变量粗略的划分为两类：类的成员变量和函数内局部变量。对于类的成员变量，当多个线程使用同一个对象时，对象中的成员变量就是共享变量，其作用域范围为多个线程均可见。多个线程竞态访问成员变量，就有可能存在线程安全问题。对于函数内局部变量，每个线程在执行函数时，会在自己的栈上创建私有的局部变量，因此，函数内局部变量的作用域范围为单线程内可见。不仅如此，函数内局部变量仅限函数内可见，不同的函数之间不可以共享局部变量。多个函数共享局部变量，需要通过参数传递的方式来实现。我们举例解释一下。","head":[["meta",{"property":"og:url","content":"https://theme-zhang.netlify.app/zh/language/Java/multithreading/lockless/ThreadLocal.html"}],["meta",{"property":"og:site_name","content":"zhang"}],["meta",{"property":"og:title","content":"ThreadLocal"}],["meta",{"property":"og:description","content":"ThreadLocal 提示 对于无锁编程，我们已经讲解了CAS、原子类、累加器，本节，我们讲解无锁编程中的最后一个知识点：ThreadLocal。我们知道，共享变量是代码存在线程安全的根本原因之一。在某些特殊的业务场景下，我们可以使用ThreadLocal线程局部变量替代共享变量，以实现在不需要加锁的情况下达到线程安全。 一、基本用法 在Java中，我们可以将变量粗略的划分为两类：类的成员变量和函数内局部变量。对于类的成员变量，当多个线程使用同一个对象时，对象中的成员变量就是共享变量，其作用域范围为多个线程均可见。多个线程竞态访问成员变量，就有可能存在线程安全问题。对于函数内局部变量，每个线程在执行函数时，会在自己的栈上创建私有的局部变量，因此，函数内局部变量的作用域范围为单线程内可见。不仅如此，函数内局部变量仅限函数内可见，不同的函数之间不可以共享局部变量。多个函数共享局部变量，需要通过参数传递的方式来实现。我们举例解释一下。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-12-09T06:04:07.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"article:modified_time","content":"2022-12-09T06:04:07.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://theme-zhang.netlify.app/en/language/Java/multithreading/lockless/ThreadLocal.html"}]]},"headers":[{"level":2,"title":"一、基本用法","slug":"一、基本用法","link":"#一、基本用法","children":[]},{"level":2,"title":"二、实现原理","slug":"二、实现原理","link":"#二、实现原理","children":[]},{"level":2,"title":"三、应用场景","slug":"三、应用场景","link":"#三、应用场景","children":[]},{"level":2,"title":"四、课后思考题","slug":"四、课后思考题","link":"#四、课后思考题","children":[]}],"git":{"createdTime":1670565847000,"updatedTime":1670565847000,"contributors":[{"name":"zhanglf","email":"454486214@qq.com","commits":1}]},"readingTime":{"minutes":7.82,"words":2346},"filePathRelative":"zh/language/Java/multithreading/lockless/ThreadLocal.md","localizedDate":"2022年12月9日","excerpt":"<h1> ThreadLocal</h1>\\n<div class=\\"custom-container tip\\">\\n<p class=\\"custom-container-title\\">提示</p>\\n<p>对于无锁编程，我们已经讲解了CAS、原子类、累加器，本节，我们讲解无锁编程中的最后一个知识点：ThreadLocal。我们知道，共享变量是代码存在线程安全的根本原因之一。在某些特殊的业务场景下，我们可以使用ThreadLocal线程局部变量替代共享变量，以实现在不需要加锁的情况下达到线程安全。</p>\\n</div>\\n<h2> <strong>一、基本用法</strong></h2>\\n<p>在Java中，我们可以将变量粗略的划分为两类：类的成员变量和函数内局部变量。对于类的成员变量，当多个线程使用同一个对象时，对象中的成员变量就是共享变量，其作用域范围为多个线程均可见。多个线程竞态访问成员变量，就有可能存在线程安全问题。对于函数内局部变量，每个线程在执行函数时，会在自己的栈上创建私有的局部变量，因此，函数内局部变量的作用域范围为单线程内可见。不仅如此，函数内局部变量仅限函数内可见，不同的函数之间不可以共享局部变量。多个函数共享局部变量，需要通过参数传递的方式来实现。我们举例解释一下。</p>","autoDesc":true}');export{e as data};
