const e=JSON.parse('{"key":"v-0d71fcd5","path":"/zh/basics/design-principles/O.html","title":"开闭原则","lang":"zh-CN","frontmatter":{"category":["设计原则和思想"],"description":"开闭原则 我个人觉得，开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。 之所以说这条原则难理解，那是因为，“怎样的代码改动才被定义为‘扩展’？怎样的代码改动才被定义为‘修改’？怎么才算满足或违反‘开闭原则’？修改代码就一定意味着违反‘开闭原则’吗？”等等这些问题，都比较难理解。 之所以说这条原则难掌握，那是因为，“如何做到‘对扩展开发、修改关闭’？如何在项目中灵活地应用‘开闭原则’，以避免在追求扩展性的同时影响到代码的可读性？”等等这些问题，都比较难掌握。 之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。","head":[["meta",{"property":"og:url","content":"https://theme-zhang.netlify.app/zh/basics/design-principles/O.html"}],["meta",{"property":"og:site_name","content":"zhang"}],["meta",{"property":"og:title","content":"开闭原则"}],["meta",{"property":"og:description","content":"开闭原则 我个人觉得，开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。 之所以说这条原则难理解，那是因为，“怎样的代码改动才被定义为‘扩展’？怎样的代码改动才被定义为‘修改’？怎么才算满足或违反‘开闭原则’？修改代码就一定意味着违反‘开闭原则’吗？”等等这些问题，都比较难理解。 之所以说这条原则难掌握，那是因为，“如何做到‘对扩展开发、修改关闭’？如何在项目中灵活地应用‘开闭原则’，以避免在追求扩展性的同时影响到代码的可读性？”等等这些问题，都比较难掌握。 之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-12-09T06:04:07.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"article:modified_time","content":"2022-12-09T06:04:07.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://theme-zhang.netlify.app/en/basics/design-principles/O.html"}]]},"headers":[{"level":2,"title":"如何理解“对扩展开放、修改关闭”？","slug":"如何理解-对扩展开放、修改关闭","link":"#如何理解-对扩展开放、修改关闭","children":[]},{"level":2,"title":"修改代码就意味着违背开闭原则吗？","slug":"修改代码就意味着违背开闭原则吗","link":"#修改代码就意味着违背开闭原则吗","children":[]},{"level":2,"title":"如何做到“对扩展开放、修改关闭”？","slug":"如何做到-对扩展开放、修改关闭","link":"#如何做到-对扩展开放、修改关闭","children":[]},{"level":2,"title":"如何在项目中灵活应用开闭原则？","slug":"如何在项目中灵活应用开闭原则","link":"#如何在项目中灵活应用开闭原则","children":[]},{"level":2,"title":"重点回顾","slug":"重点回顾","link":"#重点回顾","children":[]},{"level":2,"title":"课堂讨论","slug":"课堂讨论","link":"#课堂讨论","children":[]}],"git":{"createdTime":1670565847000,"updatedTime":1670565847000,"contributors":[{"name":"zhanglf","email":"454486214@qq.com","commits":1}]},"readingTime":{"minutes":19.44,"words":5832},"filePathRelative":"zh/basics/design-principles/O.md","localizedDate":"2022年12月9日","excerpt":"<h1> 开闭原则</h1>\\n<p>我个人觉得，开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。</p>\\n<p>之所以说这条原则难理解，那是因为，“怎样的代码改动才被定义为‘扩展’？怎样的代码改动才被定义为‘修改’？怎么才算满足或违反‘开闭原则’？修改代码就一定意味着违反‘开闭原则’吗？”等等这些问题，都比较难理解。</p>\\n<p>之所以说这条原则难掌握，那是因为，“如何做到‘对扩展开发、修改关闭’？如何在项目中灵活地应用‘开闭原则’，以避免在追求扩展性的同时影响到代码的可读性？”等等这些问题，都比较难掌握。</p>\\n<p>之所以说这条原则最有用，那是因为，扩展性是代码质量最重要的衡量标准之一。在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。</p>","autoDesc":true}');export{e as data};
