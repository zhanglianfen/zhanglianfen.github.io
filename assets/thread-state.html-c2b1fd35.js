const e=JSON.parse('{"key":"v-7b77b892","path":"/zh/language/Java/multithreading/thread-manage/thread-state.html","title":"线程状态","lang":"zh-CN","frontmatter":{"category":["Java"],"tag":["多线程"],"description":"线程状态 提示 为何synchronized和Lock这两种锁对应的线程状态不同？ 在项目开发中，当代码运行出现问题时，比如死循环、死锁等，我们一般会通过jstack工具打印线程运行信息，以此来分析问题出现的原因。线程状态是其中非常重要的一项信息。透彻的理解线程状态，比如熟悉Thread.sleep()、Object.wait()、Lock.lock()等一些常用函数与线程状态的对应关系，才能完全看懂jstack打印的线程运行信息，以便快速找出问题的原因。因此，本节我们就来详细讲一讲线程状态。 在开始本节的内容前，我还是照例给你出一个思考题：线程在执行synchronized阻塞等待锁时，对应的线程状态为BLOCKED，而线程在执行Lock锁的lock()函数阻塞等待锁时，对应的线程状态为WAITING。同样是阻塞等待锁，为什么对应的线程状态却是不同的呢？ 带着这个问题，我们来开始本节的学习。","head":[["meta",{"property":"og:url","content":"https://theme-zhang.netlify.app/zh/language/Java/multithreading/thread-manage/thread-state.html"}],["meta",{"property":"og:site_name","content":"zhang"}],["meta",{"property":"og:title","content":"线程状态"}],["meta",{"property":"og:description","content":"线程状态 提示 为何synchronized和Lock这两种锁对应的线程状态不同？ 在项目开发中，当代码运行出现问题时，比如死循环、死锁等，我们一般会通过jstack工具打印线程运行信息，以此来分析问题出现的原因。线程状态是其中非常重要的一项信息。透彻的理解线程状态，比如熟悉Thread.sleep()、Object.wait()、Lock.lock()等一些常用函数与线程状态的对应关系，才能完全看懂jstack打印的线程运行信息，以便快速找出问题的原因。因此，本节我们就来详细讲一讲线程状态。 在开始本节的内容前，我还是照例给你出一个思考题：线程在执行synchronized阻塞等待锁时，对应的线程状态为BLOCKED，而线程在执行Lock锁的lock()函数阻塞等待锁时，对应的线程状态为WAITING。同样是阻塞等待锁，为什么对应的线程状态却是不同的呢？ 带着这个问题，我们来开始本节的学习。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-12-09T06:04:07.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"article:tag","content":"多线程"}],["meta",{"property":"article:modified_time","content":"2022-12-09T06:04:07.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://theme-zhang.netlify.app/en/language/Java/multithreading/thread-manage/thread-state.html"}]]},"headers":[{"level":2,"title":"一、线程状态概述","slug":"一、线程状态概述","link":"#一、线程状态概述","children":[]},{"level":2,"title":"二、线程状态与函数对应关系","slug":"二、线程状态与函数对应关系","link":"#二、线程状态与函数对应关系","children":[]},{"level":2,"title":"三、线程状态与jstack的应用","slug":"三、线程状态与jstack的应用","link":"#三、线程状态与jstack的应用","children":[]},{"level":2,"title":"四、课后思考题","slug":"四、课后思考题","link":"#四、课后思考题","children":[]}],"git":{"createdTime":1670565847000,"updatedTime":1670565847000,"contributors":[{"name":"zhanglf","email":"454486214@qq.com","commits":1}]},"readingTime":{"minutes":11.87,"words":3560},"filePathRelative":"zh/language/Java/multithreading/thread-manage/thread-state.md","localizedDate":"2022年12月9日","excerpt":"<h1> 线程状态</h1>\\n<div class=\\"custom-container tip\\">\\n<p class=\\"custom-container-title\\">提示</p>\\n<p><strong>为何synchronized和Lock这两种锁对应的线程状态不同？</strong></p>\\n<p>在项目开发中，当代码运行出现问题时，比如死循环、死锁等，我们一般会通过jstack工具打印线程运行信息，以此来分析问题出现的原因。线程状态是其中非常重要的一项信息。透彻的理解线程状态，比如熟悉Thread.sleep()、Object.wait()、Lock.lock()等一些常用函数与线程状态的对应关系，才能完全看懂jstack打印的线程运行信息，以便快速找出问题的原因。因此，本节我们就来详细讲一讲线程状态。</p>\\n<p>在开始本节的内容前，我还是照例给你出一个思考题：线程在执行synchronized阻塞等待锁时，对应的线程状态为BLOCKED，而线程在执行Lock锁的lock()函数阻塞等待锁时，对应的线程状态为WAITING。同样是阻塞等待锁，为什么对应的线程状态却是不同的呢？</p>\\n<p>带着这个问题，我们来开始本节的学习。</p>\\n</div>","autoDesc":true}');export{e as data};
