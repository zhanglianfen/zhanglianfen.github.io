const e=JSON.parse('{"key":"v-0183ac16","path":"/zh/basics/design-patterns/creational-patterns/singleton.html","title":"单例模式","lang":"zh-CN","frontmatter":{"description":"为什么要使用单例？ 单例存在哪些问题？ 单例与静态类的区别？ 有何替代的解决方案？ 为什么要使用单例？ 单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。 对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们...","head":[["meta",{"property":"og:url","content":"https://theme-zhang.netlify.app/zh/basics/design-patterns/creational-patterns/singleton.html"}],["meta",{"property":"og:site_name","content":"zhang"}],["meta",{"property":"og:title","content":"单例模式"}],["meta",{"property":"og:description","content":"为什么要使用单例？ 单例存在哪些问题？ 单例与静态类的区别？ 有何替代的解决方案？ 为什么要使用单例？ 单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。 对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2022-12-09T06:04:07.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"article:modified_time","content":"2022-12-09T06:04:07.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://theme-zhang.netlify.app/en/basics/design-patterns/creational-patterns/singleton.html"}]]},"excerpt":"","headers":[{"level":2,"title":"为什么要使用单例？","slug":"为什么要使用单例","link":"#为什么要使用单例","children":[{"level":3,"title":"实战案例一：处理资源访问冲突","slug":"实战案例一-处理资源访问冲突","link":"#实战案例一-处理资源访问冲突","children":[]},{"level":3,"title":"实战案例二：表示全局唯一类","slug":"实战案例二-表示全局唯一类","link":"#实战案例二-表示全局唯一类","children":[]}]},{"level":2,"title":"代码示例（手写单例）","slug":"代码示例-手写单例","link":"#代码示例-手写单例","children":[{"level":3,"title":"饿汉（线程安全）","slug":"饿汉-线程安全","link":"#饿汉-线程安全","children":[]},{"level":3,"title":"懒汉（线程不安全）","slug":"懒汉-线程不安全","link":"#懒汉-线程不安全","children":[]},{"level":3,"title":"懒汉（同步锁，线程安全）","slug":"懒汉-同步锁-线程安全","link":"#懒汉-同步锁-线程安全","children":[]},{"level":3,"title":"双重校验锁（线程安全，效率高）","slug":"双重校验锁-线程安全-效率高","link":"#双重校验锁-线程安全-效率高","children":[]},{"level":3,"title":"静态内部类","slug":"静态内部类","link":"#静态内部类","children":[]},{"level":3,"title":"枚举","slug":"枚举","link":"#枚举","children":[]}]},{"level":2,"title":"单例存在哪些问题?","slug":"单例存在哪些问题","link":"#单例存在哪些问题","children":[{"level":3,"title":"1. 单例对 OOP 特性的支持不友好","slug":"_1-单例对-oop-特性的支持不友好","link":"#_1-单例对-oop-特性的支持不友好","children":[]},{"level":3,"title":"2. 单例会隐藏类之间的依赖关系","slug":"_2-单例会隐藏类之间的依赖关系","link":"#_2-单例会隐藏类之间的依赖关系","children":[]},{"level":3,"title":"3. 单例对代码的扩展性不友好","slug":"_3-单例对代码的扩展性不友好","link":"#_3-单例对代码的扩展性不友好","children":[]},{"level":3,"title":"4. 单例对代码的可测试性不友好","slug":"_4-单例对代码的可测试性不友好","link":"#_4-单例对代码的可测试性不友好","children":[]},{"level":3,"title":"5. 单例不支持有参数的构造函数","slug":"_5-单例不支持有参数的构造函数","link":"#_5-单例不支持有参数的构造函数","children":[]}]},{"level":2,"title":"有何替代解决方案？","slug":"有何替代解决方案","link":"#有何替代解决方案","children":[]},{"level":2,"title":"如何理解单例模式中的唯一性？","slug":"如何理解单例模式中的唯一性","link":"#如何理解单例模式中的唯一性","children":[]},{"level":2,"title":"如何实现线程唯一的单例？","slug":"如何实现线程唯一的单例","link":"#如何实现线程唯一的单例","children":[]},{"level":2,"title":"如何实现集群环境下的单例？","slug":"如何实现集群环境下的单例","link":"#如何实现集群环境下的单例","children":[]},{"level":2,"title":"如何实现一个多例模式？","slug":"如何实现一个多例模式","link":"#如何实现一个多例模式","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"思考题","slug":"思考题","link":"#思考题","children":[]}],"git":{"createdTime":1670565847000,"updatedTime":1670565847000,"contributors":[{"name":"zhanglf","email":"454486214@qq.com","commits":1}]},"readingTime":{"minutes":38.98,"words":11693},"autoDesc":true,"localizedDate":"2022年12月9日","filePathRelative":"zh/basics/design-patterns/creational-patterns/singleton.md"}');export{e as data};
